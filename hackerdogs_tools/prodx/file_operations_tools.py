"""
File Operations Tools
---------------------
LangChain tools for file operations and format conversion.
"""

from langchain_core.tools import BaseTool
from pydantic import BaseModel, Field
from typing import Type, Dict, Optional, Any
import sys
import os
# Try to import hd_logging
try:
    from hd_logging import setup_logger
except ImportError:
    # Fallback for testing environments
    import logging
    def setup_logger(name, log_file_path=None, **kwargs):
        logger = logging.getLogger(name)
        if not logger.handlers:
            handler = logging.StreamHandler()
            handler.setFormatter(logging.Formatter('%(name)s - %(levelname)s - %(message)s'))
            logger.addHandler(handler)
            logger.setLevel(logging.INFO)
        return logger
import base64
import io
import json

logger = setup_logger(__name__, log_file_path="logs/file_operations_tools.log")

# Try to import streamlit
try:
    import streamlit as st
    STREAMLIT_AVAILABLE = True
except ImportError:
    STREAMLIT_AVAILABLE = False
    logger.warning("streamlit not available. File download features may not work.")


def _decode_file_input(file_input: str) -> tuple[bytes, bool]:
    """Decode file input which can be either a base64 string or file path."""
    try:
        file_bytes = base64.b64decode(file_input)
        return file_bytes, True
    except Exception:
        try:
            with open(file_input, 'rb') as f:
                return f.read(), False
        except Exception as e:
            raise ValueError(f"Invalid file input: {e}")


def _encode_file_output(file_bytes: bytes) -> str:
    """Encode file bytes to base64 string."""
    return base64.b64encode(file_bytes).decode('utf-8')


# --- File Operations Tools ---

class SaveFileForDownloadInput(BaseModel):
    """Input schema for SaveFileForDownloadTool."""
    file_data: str = Field(..., description="Base64-encoded file data")
    file_name: str = Field(..., description="File name for download")
    mime_type: str = Field(..., description="MIME type of the file (e.g., 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')")
    storage_location: str = Field("session_state", description="Storage location: 'session_state' or 'temp_file' (default: 'session_state')")


class SaveFileForDownloadTool(BaseTool):
    """
    Save generated/modified files for download in Streamlit.
    
    This tool stores file data in Streamlit session state, making it available for download
    via st.download_button() in the Chat interface. It's designed to work seamlessly with
    other tools that generate or modify files (Excel, PowerPoint, etc.), providing a way
    to make those files available to users for download.
    
    **When to use this tool:**
    - Making generated files available for download
    - Saving modified Excel/PowerPoint files for user download
    - Providing file download capability in chat interface
    - Storing files generated by other tools for later download
    - Enabling users to download analysis results or reports
    - Making converted files available for download
    
    **When NOT to use this tool:**
    - For files that are already saved to disk (use file paths directly)
    - When you don't need download functionality
    - For very large files (session state has size limits)
    - When files should be temporary (consider temp_file option)
    
    **Input requirements:**
    - Must provide base64-encoded file data
    - File name should be provided with appropriate extension
    - MIME type must be specified correctly
    - Storage location defaults to session_state (recommended)
    
    **Output:**
    - Returns JSON with:
      - status: Success indicator
      - file_id: Unique identifier for the file (for download button)
      - file_name: File name
      - mime_type: MIME type
      - size: File size in bytes
      - message: Instructions for using file_id with download button
    - Returns error message if save fails
    
    **Storage Options:**
    - session_state: Stores in Streamlit session state (default, recommended)
      - Files persist for the session
      - Accessible via st.session_state.download_files
      - Best for Streamlit integration
    - temp_file: Saves to temporary file system location
      - Files may be cleaned up by system
      - Not recommended for Streamlit (use session_state instead)
    
    **Integration:**
    - Files are stored in st.session_state.download_files list
    - Each file entry has: id, name, data (base64), mime_type, size
    - Use file_id with st.download_button() to enable downloads
    - Files persist until session ends or are manually cleared
    
    **Limitations:**
    - Session state has size limits (very large files may fail)
    - Files are stored in memory (base64-encoded)
    - Files are session-specific (not persistent across sessions)
    - Multiple files accumulate in session state
    
    **Example use cases:**
    1. "Save this modified Excel file for download"
    2. "Store the generated PowerPoint presentation for user download"
    3. "Make this converted file available for download"
    4. "Save the analysis report as a downloadable file"
    
    **Configuration:**
    Requires Streamlit to be available. The tool automatically manages the download_files
    list in session state. Files are stored as base64-encoded strings for easy integration
    with Streamlit's download functionality.
    """
    name: str = "save_file_for_download"
    description: str = (
        "Save generated/modified files for download in Streamlit. "
        "Stores file data in session state for use with st.download_button(). "
        "Returns file identifier for download button integration. "
        "IMPORTANT: File data must be base64-encoded. Storage defaults to session_state. "
        "Best for: making generated files downloadable, saving modified files for download. "
        "NOT suitable for: very large files, permanent file storage, or files already on disk."
    )
    args_schema: Type[BaseModel] = SaveFileForDownloadInput

    def _run(
        self,
        file_data: str,
        file_name: str,
        mime_type: str,
        storage_location: str = "session_state"
    ) -> str:
        """
        Save file for download.
        
        This method performs the file storage operation:
        1. Validates file data (must be base64-encoded)
        2. Decodes base64 to get file bytes and size
        3. Stores file in session state or temp file based on storage_location
        4. Creates file entry with unique ID
        5. Returns file identifier and metadata
        
        Args:
            file_data: Base64-encoded file data.
                      Example: Base64 string from file generation tools
            file_name: File name for download (should include extension).
                      Example: "report.xlsx", "presentation.pptx", "analysis.pdf"
            mime_type: MIME type of the file.
                      Examples:
                      - "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" (Excel)
                      - "application/vnd.openxmlformats-officedocument.presentationml.presentation" (PowerPoint)
                      - "application/pdf" (PDF)
                      - "text/csv" (CSV)
            storage_location: Storage location:
                            - "session_state": Store in Streamlit session state (default, recommended)
                            - "temp_file": Save to temporary file (not recommended)
        
        Returns:
            str: JSON string with:
                 - status: Success indicator
                 - file_id: Unique identifier for download button (e.g., "file_0", "file_1")
                 - file_name: File name
                 - mime_type: MIME type
                 - size: File size in bytes
                 - message: Instructions for using file_id
                 Returns error message string if save fails.
        
        Raises:
            No exceptions are raised - all errors are caught and returned as error message strings.
        """
        if not STREAMLIT_AVAILABLE:
            return "Error: streamlit not available. Cannot save files for download."
        
        try:
            logger.info(f"Saving file for download: {file_name}")
            
            # Decode base64 file data
            try:
                file_bytes = base64.b64decode(file_data)
            except Exception as e:
                return f"Error: Invalid base64 file data: {str(e)}"
            
            if storage_location == "session_state":
                # Store in Streamlit session state
                if 'download_files' not in st.session_state:
                    st.session_state.download_files = []
                
                file_id = f"file_{len(st.session_state.download_files)}"
                file_entry = {
                    "id": file_id,
                    "name": file_name,
                    "data": file_data,  # Keep as base64 for easy download
                    "mime_type": mime_type,
                    "size": len(file_bytes)
                }
                
                st.session_state.download_files.append(file_entry)
                
                logger.info(f"File saved to session state: {file_id}")
                return json.dumps({
                    "status": "success",
                    "file_id": file_id,
                    "file_name": file_name,
                    "mime_type": mime_type,
                    "size": len(file_bytes),
                    "message": f"File saved. Use file_id '{file_id}' for download button."
                })
            else:
                # Save to temporary file (not recommended)
                import tempfile
                import os
                
                temp_dir = tempfile.gettempdir()
                temp_path = os.path.join(temp_dir, file_name)
                
                with open(temp_path, 'wb') as f:
                    f.write(file_bytes)
                
                logger.info(f"File saved to temporary location: {temp_path}")
                return json.dumps({
                    "status": "success",
                    "file_path": temp_path,
                    "file_name": file_name,
                    "mime_type": mime_type,
                    "size": len(file_bytes),
                    "note": "File saved to temporary location. Consider using session_state instead."
                })
            
        except Exception as e:
            logger.error(f"Error saving file for download: {str(e)}", exc_info=True)
            return f"Error saving file for download: {str(e)}"
    
    async def _arun(
        self,
        file_data: str,
        file_name: str,
        mime_type: str,
        storage_location: str = "session_state"
    ) -> str:
        """
        Async version of _run for better performance in async contexts.
        
        This method provides an asynchronous interface for file storage,
        allowing it to be used efficiently in async agent execution flows. Currently
        delegates to the synchronous _run method, but structured for future async optimization.
        
        Args:
            file_data: Base64-encoded file data
            file_name: File name for download
            mime_type: MIME type of the file
            storage_location: Storage location (session_state or temp_file)
        
        Returns:
            str: JSON string with file identifier, same as _run().
        
        Note:
            Currently implemented as a wrapper around _run() for compatibility.
            Future versions may implement true async file storage for better performance.
        """
        return self._run(file_data, file_name, mime_type, storage_location)


class ConvertFileFormatInput(BaseModel):
    """Input schema for ConvertFileFormatTool."""
    file_path: str = Field(..., description="Path to file or base64-encoded file data")
    source_format: str = Field(..., description="Source file format (e.g., 'xlsx', 'csv', 'pdf')")
    target_format: str = Field(..., description="Target file format (e.g., 'csv', 'json', 'pdf')")
    options: Optional[Dict[str, Any]] = Field(None, description="Conversion options (format-specific)")


class ConvertFileFormatTool(BaseTool):
    """
    Convert files between different formats.
    
    This tool converts files between various formats, enabling data transformation and format
    compatibility. It supports common conversions like Excel/CSV, JSON/CSV, and PDF/Images,
    making it easy to transform data for different tools or use cases.
    
    **When to use this tool:**
    - Converting file formats for compatibility
    - Transforming data between formats
    - Preparing files for different tools
    - Converting Excel to CSV for analysis
    - Converting CSV to JSON for API consumption
    - Converting PDF pages to images
    - Format transformation for tool compatibility
    
    **When NOT to use this tool:**
    - When source format is already compatible
    - For complex format conversions (may not be supported)
    - When you need to preserve all formatting (some may be lost)
    - For very large files (may be slow)
    
    **Input requirements:**
    - Must provide a valid file as base64 or file path
    - Source format must be specified correctly
    - Target format must be supported for the source format
    - Options are optional (format-specific)
    
    **Output:**
    - Returns JSON with:
      - status: Success indicator
      - file_data: Base64-encoded converted file
      - file_name: Converted file name with new extension
      - mime_type: MIME type of converted file
      - source_format: Original format
      - target_format: Target format
    - Returns error message if conversion fails
    
    **Supported Conversions:**
    - Excel → CSV: Converts .xlsx/.xls to .csv
    - CSV → Excel: Converts .csv to .xlsx
    - JSON → CSV: Converts JSON to CSV (normalizes nested structures)
    - CSV → JSON: Converts CSV to JSON array
    - PDF → Images: Converts PDF pages to PNG/JPEG (first page only in current implementation)
    - More conversions can be added as needed
    
    **Limitations:**
    - Not all format combinations are supported
    - Complex formatting may be lost in conversion
    - Large files may take time to process
    - PDF to images currently processes first page only
    - Some conversions require specific libraries
    
    **Example use cases:**
    1. "Convert this Excel file to CSV format"
    2. "Transform the JSON data into CSV format"
    3. "Convert the CSV file to JSON for API use"
    4. "Extract the first page of this PDF as an image"
    
    **Configuration:**
    Requires appropriate libraries for each conversion (pandas for Excel/CSV/JSON, pdf2image for PDF).
    The tool automatically handles base64 encoding/decoding and file I/O. Conversions preserve data
    structure where possible but may lose formatting or metadata.
    """
    name: str = "convert_file_format"
    description: str = (
        "Convert files between different formats. "
        "Supports Excel/CSV, PDF/Images, JSON/CSV conversions and more. "
        "Returns base64-encoded converted file. "
        "IMPORTANT: File can be base64-encoded string or file path. Source and target formats must be specified. "
        "Best for: format compatibility, data transformation, preparing files for different tools. "
        "NOT suitable for: complex format conversions, preserving all formatting, or very large files."
    )
    args_schema: Type[BaseModel] = ConvertFileFormatInput

    def _run(
        self,
        file_path: str,
        source_format: str,
        target_format: str,
        options: Optional[Dict[str, Any]] = None
    ) -> str:
        """
        Convert file format.
        
        This method performs the file format conversion:
        1. Decodes file input (base64 or file path)
        2. Reads file in source format
        3. Converts data to target format
        4. Encodes converted file to base64
        5. Returns converted file with metadata
        
        Args:
            file_path: Path to file or base64-encoded file data.
                      Example: "data.xlsx", "data.csv", or base64 string
            source_format: Source file format string.
                          Examples: "xlsx", "xls", "csv", "json", "pdf"
            target_format: Target file format string.
                          Examples: "csv", "xlsx", "json", "png", "jpg"
            options: Optional dictionary with conversion-specific options.
                    Format-specific options may be added in future versions.
                    Example: {"sheet_name": "Sheet1"} for Excel conversions
        
        Returns:
            str: JSON string with:
                 - status: Success indicator
                 - file_data: Base64-encoded converted file
                 - file_name: Converted file name (e.g., "converted.csv")
                 - mime_type: MIME type of converted file
                 - source_format: Original format
                 - target_format: Target format
                 Returns error message string if conversion fails.
        
        Raises:
            No exceptions are raised - all errors are caught and returned as error message strings.
        """
        try:
            logger.info(f"Converting file from {source_format} to {target_format}")
            
            # Decode file input
            file_bytes, is_base64 = _decode_file_input(file_path)
            file_obj = io.BytesIO(file_bytes)
            
            converted_bytes = None
            mime_type = None
            file_extension = None
            
            # Excel to CSV
            if source_format.lower() in ["xlsx", "xls"] and target_format.lower() == "csv":
                try:
                    import pandas as pd
                    df = pd.read_excel(file_obj)
                    output = io.StringIO()
                    df.to_csv(output, index=False)
                    converted_bytes = output.getvalue().encode('utf-8')
                    mime_type = "text/csv"
                    file_extension = "csv"
                except ImportError:
                    return "Error: pandas required for Excel to CSV conversion"
                except Exception as e:
                    return f"Error converting Excel to CSV: {str(e)}"
            
            # CSV to Excel
            elif source_format.lower() == "csv" and target_format.lower() in ["xlsx", "xls"]:
                try:
                    import pandas as pd
                    import openpyxl
                    file_obj.seek(0)
                    df = pd.read_csv(file_obj)
                    output = io.BytesIO()
                    df.to_excel(output, index=False, engine='openpyxl')
                    converted_bytes = output.getvalue()
                    mime_type = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                    file_extension = "xlsx"
                except ImportError:
                    return "Error: pandas and openpyxl required for CSV to Excel conversion"
                except Exception as e:
                    return f"Error converting CSV to Excel: {str(e)}"
            
            # JSON to CSV
            elif source_format.lower() == "json" and target_format.lower() == "csv":
                try:
                    import pandas as pd
                    import json
                    file_obj.seek(0)
                    json_data = json.load(file_obj)
                    df = pd.json_normalize(json_data)
                    output = io.StringIO()
                    df.to_csv(output, index=False)
                    converted_bytes = output.getvalue().encode('utf-8')
                    mime_type = "text/csv"
                    file_extension = "csv"
                except ImportError:
                    return "Error: pandas required for JSON to CSV conversion"
                except Exception as e:
                    return f"Error converting JSON to CSV: {str(e)}"
            
            # CSV to JSON
            elif source_format.lower() == "csv" and target_format.lower() == "json":
                try:
                    import pandas as pd
                    import json
                    file_obj.seek(0)
                    df = pd.read_csv(file_obj)
                    json_data = df.to_dict('records')
                    converted_bytes = json.dumps(json_data, indent=2).encode('utf-8')
                    mime_type = "application/json"
                    file_extension = "json"
                except ImportError:
                    return "Error: pandas required for CSV to JSON conversion"
                except Exception as e:
                    return f"Error converting CSV to JSON: {str(e)}"
            
            # PDF to Images (first page only for simplicity)
            elif source_format.lower() == "pdf" and target_format.lower() in ["png", "jpg", "jpeg"]:
                try:
                    from pdf2image import convert_from_bytes
                    from PIL import Image
                    images = convert_from_bytes(file_bytes, first_page=1, last_page=1)
                    if images:
                        output = io.BytesIO()
                        images[0].save(output, format=target_format.upper())
                        converted_bytes = output.getvalue()
                        mime_type = f"image/{target_format.lower()}"
                        file_extension = target_format.lower()
                except ImportError:
                    return "Error: pdf2image and Pillow required for PDF to image conversion"
                except Exception as e:
                    return f"Error converting PDF to image: {str(e)}"
            
            else:
                return f"Error: Unsupported conversion from {source_format} to {target_format}"
            
            if converted_bytes:
                encoded = _encode_file_output(converted_bytes)
                return json.dumps({
                    "status": "success",
                    "file_data": encoded,
                    "file_name": f"converted.{file_extension}",
                    "mime_type": mime_type,
                    "source_format": source_format,
                    "target_format": target_format
                })
            else:
                return "Error: Conversion failed"
            
        except Exception as e:
            logger.error(f"Error converting file format: {str(e)}", exc_info=True)
            return f"Error converting file format: {str(e)}"
    
    async def _arun(
        self,
        file_path: str,
        source_format: str,
        target_format: str,
        options: Optional[Dict[str, Any]] = None
    ) -> str:
        """
        Async version of _run for better performance in async contexts.
        
        This method provides an asynchronous interface for file format conversion,
        allowing it to be used efficiently in async agent execution flows. Currently
        delegates to the synchronous _run method, but structured for future async optimization.
        
        Args:
            file_path: Path to file or base64-encoded file data
            source_format: Source file format string
            target_format: Target file format string
            options: Optional conversion-specific options
        
        Returns:
            str: JSON string with converted file, same as _run().
        
        Note:
            Currently implemented as a wrapper around _run() for compatibility.
            Future versions may implement true async file I/O for better performance.
        """
        return self._run(file_path, source_format, target_format, options)

